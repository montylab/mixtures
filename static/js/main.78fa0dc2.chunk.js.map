{"version":3,"sources":["Tube.js","levels.js","NextScreen.js","LevelsScreen.js","helpers.js","Header.js","SettingsScreen.js","analytics.js","App.js","reportWebVitals.js","index.js"],"names":["Tube","layers","selected","hovered","onClick","index","withEmpties","length","push","className","style","gridArea","map","color","checkLevelCompletion","require","level","reduce","acc","tube","every","console","time","timeEnd","NextScreen","switchToNextLevel","show","title","levels","LevelsScreen","onSelectLevel","setActiveScreen","levelThreshold","parseInt","localStorage","getItem","SCREENS","game","vibrate","pattern","window","navigator","requestFunction","document","body","requestFullscreen","webkitRequestFullscreen","exitFunction","exitFullscreen","webkitExitFullscreen","toggleFullscreen","fullscreenElement","webkitIsFullScreen","call","Header","restartHandler","undoHandler","settings","xlinkHref","SettingsScreen","sendAnalyticsEvent","eventName","args","gtag","nextLevel","levelString","replace","i","App","useState","JSON","parse","stringify","tubes","setTubes","setSelected","arrowPosition","setArrowPosition","isLevelComplete","setLevelComplete","currentLevelIndex","setCurrentLevelIndex","activeScreen","setActiveScreenOriginal","actionHistory","setActionHistory","Date","now","levelSetupTimestamp","setLevelSetupTimestamp","value","setupLevel","deepcopy","setItem","toString","localLevel","isNaN","manipulateTubes","from","to","layersCount","pop","setTimeout","prevLastCompletedLevel","Math","max","solution","onkeydown","throttle","e","pos","key","history","forward","onpopstate","onunload","go","preventDefault","lastAction","updTubes","clickTubeHandler","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","getElementById"],"mappings":"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","file":"static/js/main.78fa0dc2.chunk.js","sourcesContent":["import React from 'react'\n\nconst areas = 'abcdefghijklmn'\n\nfunction Tube({layers = [], selected = false, hovered = false, onClick, index}) {\n\tconst withEmpties = [...layers]\n\twhile (withEmpties.length < 4) {\n\t\twithEmpties.push(0)\n\t}\n\treturn (\n\t\t<div\n\t\t\tclassName={`tubeWrapper ${selected ? 'selected' : ''} ${hovered ? 'hovered' : ''}`}\n\t\t\tstyle={{gridArea: areas[index]}}>\n\t\t\t<div\n\t\t\t\tclassName={`tube tube-type-1`}\n\t\t\t\tonClick={onClick}\n\t\t\t>\n\t\t\t\t{withEmpties.map((color, index) => <div className={'layer color-' + color} key={index}/>)}\n\t\t\t</div>\n\t\t\t<div className=\"arrow\"/>\n\t\t</div>\n\t)\n}\n\nexport default Tube\n","const clone = require('rfdc')()\n\nexport const levels = [\n\t[\n\t\t[1, 2, 6, 9], [12, 5, 11, 5],\n\t\t[12, 12, 7, 3], [8, 11, 10, 10],\n\t\t[7, 11, 4, 4], [1, 11, 2, 4],\n\t\t[9, 4, 8, 8], [5, 9, 5, 10],\n\t\t[6, 1, 7, 6], [7, 3, 6, 9],\n\t\t[2, 3, 8, 12], [3, 1, 10, 2],\n\t\t[], []\n\t],\n\t[\n\t\t[9, 4, 12, 12], [5, 11, 1, 3],\n\t\t[3, 9, 10, 2], [9, 1, 9, 5],\n\t\t[6, 7, 8, 7], [11, 1, 4, 2],\n\t\t[4, 6, 5, 7], [7, 4, 3, 2],\n\t\t[12, 2, 5, 8], [6, 8, 1, 10],\n\t\t[10, 11, 6, 10], [12, 3, 11, 8],\n\t\t[], []\n\t],\n\t[\n\t\t[5, 1, 11, 5], [1, 2, 1, 10],\n\t\t[4, 8, 11, 6], [7, 5, 11, 7],\n\t\t[10, 3, 9, 6], [5, 11, 8, 10],\n\t\t[3, 7, 9, 4], [4, 7, 2, 9],\n\t\t[6, 8, 2, 6], [3, 10, 8, 3],\n\t\t[1, 4, 9, 2], [],\n\t\t[]\n\t],\n\t[\n\t\t[1, 1, 1, 4],\n\t\t[4, 4, 4, 1],\n\t\t[2, 2, 2, 2],\n\t\t[3, 3, 3, 3],\n\t\t[],\n\t\t[]\n\t],\n\t[\n\t\t[1, 2, 3, 4],\n\t\t[1, 2, 3, 4],\n\t\t[1, 2, 3, 4],\n\t\t[1, 2, 3, 4],\n\t\t[],\n\t\t[]\n\t],\n\t[\n\t\t[],\n\t\t[1],\n\t\t[2, 1, 1, 1],\n\t\t[2, 2, 2],\n\t\t[3, 3, 3, 3],\n\t\t[4, 4, 4, 4]\n\t],\n\t[\n\t\t[1, 2, 3, 4],\n\t\t[1, 2, 3, 4],\n\t\t[1, 2, 3, 4],\n\t\t[1, 2, 3, 4],\n\t\t[5, 6, 6, 5],\n\t\t[6, 6, 5, 5],\n\t\t[],\n\t\t[]\n\t],\n\t[\n\t\t[1, 3, 2, 1],\n\t\t[6, 5, 5, 4],\n\t\t[9, 7, 5, 9],\n\t\t[2, 3, 4, 6],\n\t\t[5, 4, 8, 2],\n\t\t[8, 1, 3, 7],\n\t\t[7, 1, 3, 4],\n\t\t[7, 2, 8, 9],\n\t\t[9, 6, 6, 8],\n\t\t[],\n\t\t[]\n\t],\n]\n\nexport const generateLevel = (colors = 11) => {\n\tconst level = []\n\tconst colorsCount = 4 + Math.ceil(Math.random() * colors - 4)\n\tlet levelString = ''\n\tfor (let i = 1; i <= colorsCount; i++) {\n\t\tlevelString += i.toString().repeat(4)\n\t}\n\tconst levelArray = levelString\n\t\t.split('')\n\t\t.sort(() => Math.random() - 0.5)\n\n\tfor (let i = 0; i < colorsCount * 4; i++) {\n\t\tconst tubeIndex = Math.floor(i / 4)\n\t\tlevel[tubeIndex] = level[tubeIndex] || []\n\t\tlevel[tubeIndex].push(levelArray[i])\n\t}\n\n\tlevel.push([], [])\n\n\treturn level\n}\n\nexport const checkLevelCompletion = (level) => {\n\treturn level.reduce((acc, tube) => {\n\t\treturn acc && tube.length % 4 === 0 && tube.every(color => color === tube[0])\n\t}, true)\n}\n\n\nconst getActionIfPossible = (tubes, fromIndex, toIndex) => {\n\tlet layers = 0\n\n\tif (fromIndex !== toIndex) {\n\t\tconst maxLayersToReceive = 4 - tubes[toIndex].length\n\t\tconst originLastIndex = tubes[fromIndex].length - 1\n\t\tlet maxLayersToMove = 0\n\n\t\tif (\n\t\t\t(tubes[fromIndex][tubes[fromIndex].length - 1] === tubes[toIndex][tubes[toIndex].length - 1])\n\t\t\t|| tubes[toIndex].length === 0\n\t\t) {\n\t\t\tmaxLayersToMove = 1\n\t\t\tif (tubes[fromIndex][originLastIndex] === tubes[fromIndex][originLastIndex - 1]) {\n\t\t\t\tmaxLayersToMove = 2\n\t\t\t\tif (tubes[fromIndex][originLastIndex] === tubes[fromIndex][originLastIndex - 2]) {\n\t\t\t\t\tmaxLayersToMove = 3\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tlayers = Math.min(maxLayersToMove, maxLayersToReceive)\n\n\t\t//tubes[fromIndex].join('').\n\n\t\t// const from = [...tubes[fromIndex]]\n\t\t// const to = [...tubes[toIndex]]\n\t\t//\n\t\t// while (\n\t\t//     from.length !== 0 && to.length !== 4\n\t\t//     && (from[from.length - 1] === to[to.length - 1] || to.length === 0)\n\t\t//     ) {\n\t\t//     to.push(from.pop())\n\t\t//     layers++\n\t\t// }\n\t}\n\n\treturn layers && {from: fromIndex, to: toIndex, layers}\n}\n\nconst applyActionToLevel = ({from, to, layers}, level) => {\n\tconst updated = clone(level) //JSON.parse(JSON.stringify(level))\n\tfor (let i = 0; i < layers; i++) {\n\t\tupdated[to].push(updated[from].pop())\n\t}\n\n\treturn updated\n}\n\nconst isActionDumb = (level, {from, to, layers}) => {\n\tif (!layers) {\n\t\treturn true\n\t}\n\n\t// from all layers from one to empty tube\n\tif (level[to].length === 0 && layers === level[from].length) {\n\t\treturn true\n\t}\n\n\tconst color = level[from][level[from].length - 1]\n\n\t// move not all layers of same color\n\tif (level[from][level[from].length - layers - 1] === color) {\n\t\treturn true\n\t}\n\n\t// if two empties, do not use second\n\tconst emptyTubes = level.filter(tube => tube.length === 0)\n\tif (emptyTubes[1] === level[to]) {\n\t\treturn true\n\t}\n\n\t// if action is move layer to empty tube, when exists tube with all layers of the same color\n\t//const emptyTubes = level.filter(tube => tube.length === 0)\n\tconst sameColorTubes = level.filter(\n\t\ttube => tube.length && tube.every(layer => layer === color)\n\t)\n\tif (level[to].length === 0 && sameColorTubes.length) {\n\t\treturn true\n\t}\n\n\treturn false\n}\n\nlet totalCalls = 0\nexport const findLevelSolution = (level, previousActions = []) => {\n\ttotalCalls++\n\tif (previousActions.length === 30) {\n\t\t//console.log(JSON.stringify(previousActions))\n\t\t//console.count('not found')\n\n\t\tif (totalCalls % 1000000 === 0) {\n\t\t\tconsole.log(JSON.stringify(previousActions))\n\t\t}\n\n\t\treturn []\n\t}\n\n\tconst solutions = []\n\n\tconst levelLength = level.length\n\tfor (let from = 0; from < levelLength; from++) {\n\t\tfor (let to = 0; to < levelLength; to++) {\n\t\t\tconst action = getActionIfPossible(level, from, to)\n\n\t\t\tif (!action || isActionDumb(level, action)) {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tconst updatedLevel = applyActionToLevel(action, level)\n\t\t\tconst isComplete = checkLevelCompletion(updatedLevel)\n\t\t\tconst actionsQueue = [...previousActions, action]\n\n\t\t\tif (isComplete) {\n\t\t\t\tsolutions.push(actionsQueue)\n\t\t\t\tif (solutions.length > 1000) {\n\t\t\t\t\treturn solutions\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst childSolutions = findLevelSolution(updatedLevel, [...previousActions, action])\n\t\t\tsolutions.push(...childSolutions)\n\t\t}\n\t}\n\n\treturn solutions\n}\n\n\nconsole.time()\n// const solutions = findLevelSolution(levels[4])\n// console.log(solutions, totalCalls)\nconsole.timeEnd()","import React from 'react'\n\nfunction NextScreen({switchToNextLevel, show}) {\n\treturn (\n\t\t<div className={`screen nextScreen ${show && 'show'}`}>\n\t\t\t<h1>Great Job!</h1>\n\n\t\t\t<button\n\t\t\t\ttitle=\"Next level\"\n\t\t\t\tclassName=\"nextLevelBtn btn linkBtn\"\n\t\t\t\tonClick={switchToNextLevel}\n\t\t\t>\n\t\t\t\tNext Level\n\t\t\t</button>\n\t\t</div>\n\t)\n}\n\nexport default NextScreen\n","import React from 'react'\nimport {SCREENS} from './App'\n\nconst levels = require('./levels-setup.json')\n\nfunction LevelsScreen({onSelectLevel, show, setActiveScreen}) {\n\tconst levelThreshold = (parseInt(localStorage.getItem('last-completed-level')) || 0) + 1\n\n\treturn (\n\t\t<div className={`screen levelsScreen ${show && 'show'}`}>\n\t\t\t<h1>Choose Level</h1>\n\n\t\t\t{show && <>\n\t\t\t\t<div className=\"levelsBtnsWrapper\">\n\t\t\t\t\t{levels.map((level, index) => (\n\t\t\t\t\t\t<button\n\t\t\t\t\t\t\tonClick={() => index <= /*levelThreshold &&*/ onSelectLevel(index)}\n\t\t\t\t\t\t\tclassName={`levelNumberBtn linkBtn ${index >= 100 ? 'threeDigits' : ''}  ${index > levelThreshold ? 'disabledLevel' : ''}`}\n\t\t\t\t\t\t\tkey={index}\n\t\t\t\t\t\t>{index + 1}</button>\n\t\t\t\t\t))}\n\t\t\t\t</div>\n\n\t\t\t\t<button\n\t\t\t\t\ttitle=\"Go back\"\n\t\t\t\t\tclassName=\"backBtn btn linkBtn\"\n\t\t\t\t\tonClick={() => setActiveScreen(SCREENS.game)}\n\t\t\t\t>\n\t\t\t\t\tGo Back\n\t\t\t\t</button>\n\t\t\t</>}\n\t\t</div>\n\t)\n}\n\nexport default LevelsScreen\n","export const vibrate = (pattern = 200) => {\n\tif (window.navigator.vibrate) {\n\t\twindow.navigator.vibrate(pattern)\n\t}\n}","import React from 'react'\nimport {SCREENS} from './App'\nimport {vibrate} from './helpers'\n\n\nconst requestFunction = document.body.requestFullscreen || document.body.webkitRequestFullscreen || (() => {\n})\nconst exitFunction = document.exitFullscreen || document.webkitExitFullscreen || (() => {\n})\nconst toggleFullscreen = () => {\n\tconst fullScreenState = document.fullscreenElement || document.webkitIsFullScreen || false\n\n\tif (fullScreenState) {\n\t\texitFunction.call(document)\n\t} else {\n\t\trequestFunction.call(document.body)\n\t}\n\n\tvibrate(200)\n}\n\n\nexport const Header = ({setActiveScreen, restartHandler, undoHandler}) => {\n\n\treturn <div className=\"header\">\n\t\t<button\n\t\t\tonClick={() => setActiveScreen(SCREENS.settings)}\n\t\t\tclassName=\"settingsBtn btn linkBtn\"\n\t\t\ttitle=\"Settings\"\n\t\t>\n\t\t\t<svg>\n\t\t\t\t<use xlinkHref=\"#icon-settings\"/>\n\t\t\t</svg>\n\t\t</button>\n\n\t\t<button\n\t\t\tonClick={() => setActiveScreen(SCREENS.levels)}\n\t\t\tclassName=\"levelsBtn btn linkBtn\"\n\t\t\ttitle=\"Choose Level\"\n\t\t>\n\t\t\t<svg>\n\t\t\t\t<use xlinkHref=\"#icon-levels\"/>\n\t\t\t</svg>\n\t\t</button>\n\n\t\t<button\n\t\t\tonClick={toggleFullscreen}\n\t\t\tclassName=\"fullscreenBtn btn linkBtn\"\n\t\t\ttitle=\"Switch To Full Screen\"\n\t\t>\n\t\t\t<svg>\n\t\t\t\t<use xlinkHref=\"#icon-fullscreen\"/>\n\t\t\t</svg>\n\t\t</button>\n\n\t\t<button\n\t\t\tonClick={restartHandler}\n\t\t\tclassName=\"restartBtn btn linkBtn\"\n\t\t\ttitle=\"Restart Level\"\n\t\t>\n\t\t\t<svg>\n\t\t\t\t<use xlinkHref=\"#icon-reload\"/>\n\t\t\t</svg>\n\t\t</button>\n\n\t\t<button\n\t\t\tonClick={undoHandler}\n\t\t\tclassName=\"undoBtn btn linkBtn\"\n\t\t\ttitle=\"Undo\"\n\t\t>\n\t\t\t<svg>\n\t\t\t\t<use xlinkHref=\"#icon-undo\"/>\n\t\t\t</svg>\n\t\t</button>\n\t</div>\n}","import React from 'react'\nimport {SCREENS} from './App'\n\nfunction SettingsScreen({setActiveScreen, show}) {\n\treturn (\n\t\t<div className={`screen settingsScreen ${show && 'show'}`}>\n\t\t\t<h1>Settings</h1>\n\n\t\t\t<button\n\t\t\t\ttitle=\"Go back\"\n\t\t\t\tclassName=\"backBtn btn linkBtn\"\n\t\t\t\tonClick={() => setActiveScreen(SCREENS.game)}\n\t\t\t>\n\t\t\t\tGo Back\n\t\t\t</button>\n\t\t</div>\n\t)\n}\n\nexport default SettingsScreen\n","export const sendAnalyticsEvent = (eventName: string, args: any) => {\n\t// @ts-ignore\n\twindow.gtag('event', eventName, args)\n}","import './css/App.css'\nimport Tube from './Tube'\nimport React, {useState} from 'react'\nimport {checkLevelCompletion} from './levels.js'\nimport {throttle} from 'throttle-debounce'\nimport NextScreen from './NextScreen'\nimport LevelsScreen from './LevelsScreen'\nimport deepcopy from 'deepcopy'\nimport {Header} from './Header'\nimport SettingsScreen from './SettingsScreen'\nimport {sendAnalyticsEvent} from './analytics'\nimport {vibrate} from './helpers'\n\nexport const SCREENS = {\n\tgame: 'game',\n\tnextLevel: 'nextLevel',\n\tsettings: 'settings',\n\tlevels: 'levels',\n}\n\nconst parseLevel = (levelString) => {\n\tlevelString = levelString.replace(/:.*:.*$/, '')\n\n\tconst level = []\n\tfor (let i = 0; i < levelString.length / 4; i++) {\n\t\tlevel[i] = [\n\t\t\tparseInt(levelString[i * 4], 32),\n\t\t\tparseInt(levelString[i * 4 + 1], 32),\n\t\t\tparseInt(levelString[i * 4 + 2], 32),\n\t\t\tparseInt(levelString[i * 4 + 3], 32)\n\t\t]\n\t}\n\n\tlevel.push([], [])\n\n\treturn level\n}\nconst levels = require('./levels-setup.json').map(parseLevel)\n\nfunction App() {\n\tconst [tubes, setTubes] = useState(JSON.parse(JSON.stringify(levels[0])))\n\tconst [selected, setSelected] = useState(-1)\n\tconst [arrowPosition, setArrowPosition] = useState(-1)\n\tconst [isLevelComplete, setLevelComplete] = useState(false)\n\tconst [currentLevelIndex, setCurrentLevelIndex] = useState(0)\n\tconst [activeScreen, setActiveScreenOriginal] = useState('gameScreen')\n\tconst [actionHistory, setActionHistory] = useState([])\n\tconst [levelSetupTimestamp, setLevelSetupTimestamp] = useState(Date.now())\n\n\tconst setActiveScreen = (value) => {\n\t\tsetActiveScreenOriginal(value)\n\t\tvibrate(100)\n\t\tsendAnalyticsEvent('activate_screen-value', {level: currentLevelIndex})\n\t}\n\n\tconst setupLevel = (index = currentLevelIndex) => {\n\t\tif (levels[index]) {\n\t\t\tsetTubes(deepcopy(levels[index]))\n\t\t\tsetActionHistory([])\n\t\t\tsetLevelComplete(false)\n\t\t\tsetActiveScreen(SCREENS.game)\n\n\t\t\tif (index !== currentLevelIndex) {\n\t\t\t\tsetLevelSetupTimestamp(Date.now())\n\t\t\t}\n\n\t\t\tsetSelected(-1)\n\t\t\tsetCurrentLevelIndex(index)\n\t\t\tlocalStorage.setItem('level', index.toString())\n\n\n\t\t\tsendAnalyticsEvent('setup_level', {index, level: levels[index]})\n\t\t}\n\t}\n\n\tconst localLevel = parseInt(localStorage.getItem('level'))\n\tif (!isNaN(localLevel) && localLevel !== currentLevelIndex) {\n\t\tsetupLevel(localLevel)\n\t}\n\n\tconst manipulateTubes = (index) => {\n\t\tif (selected === -1) {\n\t\t\tsetSelected(index)\n\t\t} else {\n\t\t\tif (index !== selected) {\n\t\t\t\tconst from = tubes[selected]\n\t\t\t\tconst to = tubes[index]\n\n\t\t\t\tlet layersCount = 0\n\t\t\t\twhile (\n\t\t\t\t\tfrom.length !== 0 && to.length !== 4\n\t\t\t\t\t&& (from[from.length - 1] === to[to.length - 1] || to.length === 0)\n\t\t\t\t\t) {\n\t\t\t\t\tto.push(from.pop())\n\t\t\t\t\tlayersCount++\n\t\t\t\t}\n\n\t\t\t\tif (layersCount) {\n\t\t\t\t\tsetActionHistory([...actionHistory, {from: selected, to: index, layers: layersCount}])\n\t\t\t\t\tsetTubes(tubes)\n\n\t\t\t\t\tvibrate(10)\n\t\t\t\t}\n\n\t\t\t\tsetSelected(layersCount ? -1 : index)\n\t\t\t} else {\n\t\t\t\tsetSelected(selected === index ? -1 : index)\n\t\t\t}\n\t\t}\n\n\t\tif (checkLevelCompletion(tubes)) {\n\t\t\tvibrate([50, 50, 100, 50, 300])\n\n\t\t\tsetTimeout(() => {\n\t\t\t\tsetLevelComplete(true)\n\n\t\t\t\tconst prevLastCompletedLevel = parseInt(localStorage.getItem('last-completed-level'))\n\t\t\t\tlocalStorage.setItem('last-completed-level', Math.max(currentLevelIndex, prevLastCompletedLevel).toString())\n\t\t\t\tsetActiveScreen(SCREENS.nextLevel)\n\n\t\t\t\tsendAnalyticsEvent('level_completed', {\n\t\t\t\t\tindex: currentLevelIndex,\n\t\t\t\t\tlevel: levels[currentLevelIndex],\n\t\t\t\t\tsolution: actionHistory,\n\t\t\t\t\ttime: (Date.now() - levelSetupTimestamp) / 1000\n\t\t\t\t})\n\n\n\t\t\t}, 500)\n\t\t}\n\t}\n\n\tconst keyupHandler = (e) => {\n\t\tif (!e) return\n\n\t\tlet pos\n\t\tif (e.key === 'ArrowRight') {\n\t\t\tpos = arrowPosition + 1\n\t\t\tsendAnalyticsEvent('tube_key-right', {level: currentLevelIndex})\n\t\t} else if (e.key === 'ArrowLeft') {\n\t\t\tpos = arrowPosition - 1\n\t\t\tsendAnalyticsEvent('tube_key-left', {level: currentLevelIndex})\n\t\t} else if (e.key === 'Enter') {\n\t\t\tif (activeScreen === 'nextScreen') {\n\t\t\t\tsetupLevel(currentLevelIndex + 1)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif (selected === -1) {\n\t\t\t\tsetSelected(arrowPosition)\n\t\t\t} else if (arrowPosition === selected) {\n\t\t\t\tsetSelected(-1)\n\t\t\t} else {\n\t\t\t\tmanipulateTubes(arrowPosition)\n\t\t\t\tsendAnalyticsEvent('tube_keydown', {level: currentLevelIndex})\n\t\t\t}\n\n\t\t\treturn\n\t\t}\n\n\t\tif (pos > tubes.length - 1) {\n\t\t\tpos = 0\n\t\t} else if (pos < 0) {\n\t\t\tpos = tubes.length - 1\n\t\t}\n\n\t\tsetArrowPosition(!isNaN(pos) ? pos : -1)\n\t}\n\n\t// rewrite every render to have binding to setState, call it to prevent new function after reload reload\n\twindow.onkeydown = throttle(100, false, keyupHandler)\n\twindow.onkeydown()\n\n\twindow.history.forward();\n\twindow.onpopstate = window.onunload = function (e) {\n\t\twindow.history.go(1);\n\t\te.preventDefault()\n\t};\n\n\n\tconst clickTubeHandler = (index) => {\n\t\tsetArrowPosition(-1)\n\t\tsendAnalyticsEvent('tube_clicked', {level: currentLevelIndex})\n\t\tmanipulateTubes(index)\n\t}\n\n\tconst undo = () => {\n\t\tconst lastAction = actionHistory.pop()\n\t\tif (lastAction) {\n\t\t\tconst updTubes = deepcopy(tubes)\n\t\t\tfor (let i = 0; i < lastAction.layers; i++) {\n\t\t\t\tupdTubes[lastAction.from].push(updTubes[lastAction.to].pop())\n\t\t\t}\n\n\t\t\tsetTubes(updTubes)\n\t\t\tsetActionHistory(actionHistory)\n\t\t\tsendAnalyticsEvent('tube_left', {level: currentLevelIndex})\n\t\t\tvibrate(70)\n\t\t}\n\t}\n\n\tconst restartLevel = () => {\n\t\tsendAnalyticsEvent('level_restarted', {\n\t\t\tindex: currentLevelIndex,\n\t\t\tlevel: levels[currentLevelIndex],\n\t\t\thistory: actionHistory,\n\t\t\ttime: (Date.now() - levelSetupTimestamp) / 1000\n\t\t})\n\n\t\tsetupLevel()\n\t\tvibrate(150)\n\t}\n\n\treturn (\n\t\t<div className=\"App\">\n\t\t\t<Header\n\t\t\t\tundoHandler={undo}\n\t\t\t\trestartHandler={restartLevel}\n\t\t\t\tsetActiveScreen={setActiveScreen}\n\t\t\t/>\n\n\t\t\t<div className=\"levelWrapper\">\n\t\t\t\t<h1 className=\"levelTitle\">Level: {currentLevelIndex + 1} {isLevelComplete && ' - completed!'}</h1>\n\n\t\t\t\t<div className={'level level-tubes-' + tubes.length}>\n\t\t\t\t\t{tubes.map((layers, index) => (\n\t\t\t\t\t\t<Tube\n\t\t\t\t\t\t\tlayers={layers}\n\t\t\t\t\t\t\tselected={index === selected}\n\t\t\t\t\t\t\thovered={index === arrowPosition}\n\t\t\t\t\t\t\tonClick={() => clickTubeHandler(index)}\n\t\t\t\t\t\t\tindex={index}\n\t\t\t\t\t\t\tkey={index}\n\t\t\t\t\t\t/>\n\t\t\t\t\t))}\n\t\t\t\t</div>\n\t\t\t</div>\n\n\t\t\t<NextScreen\n\t\t\t\tshow={activeScreen === SCREENS.nextLevel}\n\t\t\t\tswitchToNextLevel={() => setupLevel(currentLevelIndex + 1)}\n\t\t\t/>\n\n\t\t\t<LevelsScreen\n\t\t\t\tshow={activeScreen === SCREENS.levels}\n\t\t\t\tonSelectLevel={setupLevel}\n\t\t\t\tsetActiveScreen={setActiveScreen}\n\t\t\t/>\n\n\t\t\t<SettingsScreen\n\t\t\t\tshow={activeScreen === SCREENS.settings}\n\t\t\t\tsetActiveScreen={setActiveScreen}\n\t\t\t/>\n\t\t</div>\n\t)\n}\n\nexport default App","const reportWebVitals = onPerfEntry => {\n\tif (onPerfEntry && onPerfEntry instanceof Function) {\n\t\timport('web-vitals').then(({getCLS, getFID, getFCP, getLCP, getTTFB}) => {\n\t\t\tgetCLS(onPerfEntry)\n\t\t\tgetFID(onPerfEntry)\n\t\t\tgetFCP(onPerfEntry)\n\t\t\tgetLCP(onPerfEntry)\n\t\t\tgetTTFB(onPerfEntry)\n\t\t})\n\t}\n}\n\nexport default reportWebVitals\n","import React from 'react'\nimport ReactDOM from 'react-dom'\nimport App from './App'\nimport reportWebVitals from './reportWebVitals'\n\nReactDOM.render(\n\t<React.StrictMode>\n\t\t<App/>\n\t</React.StrictMode>,\n\tdocument.getElementById('root')\n)\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals()\n"],"sourceRoot":""}