{"version":3,"sources":["Tube.js","levels.js","NextScreen.js","LevelsScreen.js","Header.js","SettingsScreen.js","analytics.js","App.js","reportWebVitals.js","index.js"],"names":["Tube","layers","selected","hovered","onClick","withEmpties","length","push","className","map","color","index","checkLevelCompletion","require","level","reduce","acc","tube","every","console","time","timeEnd","NextScreen","switchToNextLevel","show","title","levels","LevelsScreen","onSelectLevel","setActiveScreen","levelThreshold","parseInt","localStorage","getItem","SCREENS","game","requestFunction","document","body","requestFullscreen","webkitRequestFullscreen","exitFunction","exitFullscreen","webkitExitFullscreen","toggleFullscreen","fullscreenElement","webkitIsFullScreen","call","window","navigator","vibrate","Header","restartHandler","undoHandler","settings","xlinkHref","SettingsScreen","sendAnalyticsEvent","eventName","args","gtag","nextLevel","levelString","i","App","useState","JSON","parse","stringify","tubes","setTubes","setSelected","arrowPosition","setArrowPosition","isLevelComplete","setLevelComplete","currentLevelIndex","setCurrentLevelIndex","activeScreen","setActiveScreenOriginal","actionHistory","setActionHistory","Date","now","levelSetupTimestamp","setLevelSetupTimestamp","value","setupLevel","deepcopy","setItem","toString","localLevel","isNaN","manipulateTubes","from","to","layersCount","pop","setTimeout","prevLastCompletedLevel","Math","max","solution","onkeydown","throttle","e","pos","key","lastAction","updTubes","history","clickTubeHandler","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","getElementById"],"mappings":"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","file":"static/js/main.edc08259.chunk.js","sourcesContent":["import React from \"react\";\n\nfunction Tube({layers = [], selected = false, hovered = false, onClick}) {\n    const withEmpties = [...layers]\n    while (withEmpties.length < 4) {\n        withEmpties.push(0)\n    }\n    return (\n        <div className={`tubeWrapper ${selected ? 'selected' : ''} ${hovered ? 'hovered' : ''}`}>\n            <div\n                className={`tube tube-type-1`}\n                onClick={onClick}\n            >\n                {withEmpties.map((color, index) => <div className={'layer color-' + color} key={index}/>)}\n            </div>\n            <div className=\"arrow\" />\n        </div>\n    );\n}\n\nexport default Tube;\n","const clone = require('rfdc')()\n\nexport const levels = [\n    [\n        [ 1, 2, 6, 9 ],   [ 12, 5, 11, 5 ],\n        [ 12, 12, 7, 3 ], [ 8, 11, 10, 10 ],\n        [ 7, 11, 4, 4 ],  [ 1, 11, 2, 4 ],\n        [ 9, 4, 8, 8 ],   [ 5, 9, 5, 10 ],\n        [ 6, 1, 7, 6 ],   [ 7, 3, 6, 9 ],\n        [ 2, 3, 8, 12 ],  [ 3, 1, 10, 2 ],\n        [],               []\n    ],\n    [\n        [9, 4, 12, 12], [5, 11, 1, 3],\n        [3, 9, 10, 2], [9, 1, 9, 5],\n        [6, 7, 8, 7], [11, 1, 4, 2],\n        [4, 6, 5, 7], [7, 4, 3, 2],\n        [12, 2, 5, 8], [6, 8, 1, 10],\n        [10, 11, 6, 10], [12, 3, 11, 8],\n        [], []\n    ],\n    [\n        [5, 1, 11, 5], [1, 2, 1, 10],\n        [4, 8, 11, 6], [7, 5, 11, 7],\n        [10, 3, 9, 6], [5, 11, 8, 10],\n        [3, 7, 9, 4], [4, 7, 2, 9],\n        [6, 8, 2, 6], [3, 10, 8, 3],\n        [1, 4, 9, 2], [],\n        []\n    ],\n    [\n        [1, 1, 1, 4],\n        [4, 4, 4, 1],\n        [2, 2, 2, 2],\n        [3, 3, 3, 3],\n        [],\n        []\n    ],\n    [\n        [1, 2, 3, 4],\n        [1, 2, 3, 4],\n        [1, 2, 3, 4],\n        [1, 2, 3, 4],\n        [],\n        []\n    ],\n    [\n        [],\n        [1],\n        [2, 1, 1, 1],\n        [2, 2, 2],\n        [3, 3, 3, 3],\n        [4, 4, 4, 4]\n    ],\n    [\n        [1, 2, 3, 4],\n        [1, 2, 3, 4],\n        [1, 2, 3, 4],\n        [1, 2, 3, 4],\n        [5, 6, 6, 5],\n        [6, 6, 5, 5],\n        [],\n        []\n    ],\n    [\n        [1, 3, 2, 1],\n        [6, 5, 5, 4],\n        [9, 7, 5, 9],\n        [2, 3, 4, 6],\n        [5, 4, 8, 2],\n        [8, 1, 3, 7],\n        [7, 1, 3, 4],\n        [7, 2, 8, 9],\n        [9, 6, 6, 8],\n        [],\n        []\n    ],\n]\n\nexport const generateLevel = (colors = 11) => {\n    const level = []\n    const colorsCount = 4 + Math.ceil(Math.random() * colors - 4)\n    let levelString = ''\n    for (let i = 1; i <= colorsCount; i++) {\n        levelString += i.toString().repeat(4)\n    }\n    const levelArray = levelString\n        .split('')\n        .sort(() => Math.random() - 0.5)\n\n    for (let i = 0; i < colorsCount * 4; i++) {\n        const tubeIndex = Math.floor(i / 4)\n        level[tubeIndex] = level[tubeIndex] || []\n        level[tubeIndex].push(levelArray[i])\n    }\n\n    level.push([], [])\n\n    return level\n}\n\nexport const checkLevelCompletion = (level) => {\n    return level.reduce((acc, tube) => {\n        return acc && tube.length % 4 === 0 && tube.every(color => color === tube[0])\n    }, true)\n}\n\n\nconst getActionIfPossible = (tubes, fromIndex, toIndex) => {\n    let layers = 0\n\n    if (fromIndex !== toIndex) {\n        const maxLayersToReceive = 4 - tubes[toIndex].length\n        const originLastIndex = tubes[fromIndex].length - 1\n        let maxLayersToMove = 0\n\n        if (\n            (tubes[fromIndex][tubes[fromIndex].length - 1] === tubes[toIndex][tubes[toIndex].length - 1])\n            || tubes[toIndex].length === 0\n        ) {\n            maxLayersToMove = 1\n            if (tubes[fromIndex][originLastIndex] === tubes[fromIndex][originLastIndex - 1]) {\n                maxLayersToMove = 2\n                if (tubes[fromIndex][originLastIndex] === tubes[fromIndex][originLastIndex - 2]) {\n                    maxLayersToMove = 3\n                }\n            }\n        }\n\n        layers = Math.min(maxLayersToMove, maxLayersToReceive)\n\n        //tubes[fromIndex].join('').\n\n        // const from = [...tubes[fromIndex]]\n        // const to = [...tubes[toIndex]]\n        //\n        // while (\n        //     from.length !== 0 && to.length !== 4\n        //     && (from[from.length - 1] === to[to.length - 1] || to.length === 0)\n        //     ) {\n        //     to.push(from.pop())\n        //     layers++\n        // }\n    }\n\n    return layers && {from: fromIndex, to: toIndex, layers}\n}\n\nconst applyActionToLevel = ({from, to, layers}, level) => {\n    const updated = clone(level) //JSON.parse(JSON.stringify(level))\n    for (let i = 0; i < layers; i++) {\n        updated[to].push(updated[from].pop())\n    }\n\n    return updated\n}\n\nconst isActionDumb = (level, {from, to, layers}) => {\n    if (!layers) {\n        return true\n    }\n\n    // from all layers from one to empty tube\n    if (level[to].length === 0 && layers === level[from].length) {\n        return true\n    }\n\n    const color = level[from][level[from].length - 1]\n\n    // move not all layers of same color\n    if (level[from][level[from].length - layers - 1] === color) {\n        return true\n    }\n\n    // if two empties, do not use second\n    const emptyTubes = level.filter(tube => tube.length === 0)\n    if (emptyTubes[1] === level[to]) {\n        return true\n    }\n\n    // if action is move layer to empty tube, when exists tube with all layers of the same color\n    //const emptyTubes = level.filter(tube => tube.length === 0)\n    const sameColorTubes = level.filter(\n        tube => tube.length && tube.every(layer => layer === color)\n    )\n    if (level[to].length === 0 && sameColorTubes.length) {\n        return true\n    }\n\n    return false\n}\n\nlet totalCalls = 0\nexport const findLevelSolution = (level, previousActions = []) => {\n    totalCalls++\n    if (previousActions.length === 30) {\n        //console.log(JSON.stringify(previousActions))\n        //console.count('not found')\n\n        if (totalCalls % 1000000 === 0) {\n            console.log(JSON.stringify(previousActions))\n        }\n\n        return []\n    }\n\n    const solutions = []\n\n    const levelLength = level.length\n    for (let from = 0; from < levelLength; from++) {\n        for (let to = 0; to < levelLength; to++) {\n            const action = getActionIfPossible(level, from, to)\n\n            if (!action || isActionDumb(level, action)) {\n                continue\n            }\n            const updatedLevel = applyActionToLevel(action, level)\n            const isComplete = checkLevelCompletion(updatedLevel)\n            const actionsQueue = [...previousActions, action]\n\n            if (isComplete) {\n                solutions.push(actionsQueue)\n                if (solutions.length > 1000) {\n                    return solutions\n                }\n            }\n\n            const childSolutions = findLevelSolution(updatedLevel, [...previousActions, action])\n            solutions.push(...childSolutions)\n        }\n    }\n\n    return solutions\n}\n\n\nconsole.time()\n// const solutions = findLevelSolution(levels[4])\n// console.log(solutions, totalCalls)\nconsole.timeEnd()","import React from \"react\";\n\nfunction NextScreen({switchToNextLevel, show}) {\n    return (\n        <div className={`screen nextScreen ${show && 'show'}`} >\n            <h1>Great Job!</h1>\n\n            <button\n               title=\"Next level\"\n               className=\"nextLevelBtn btn linkBtn\"\n               onClick={switchToNextLevel}\n            >\n                Next Level\n            </button>\n        </div>\n    );\n}\n\nexport default NextScreen;\n","import React from \"react\";\nimport {SCREENS} from \"./App\";\n\nconst levels = require('./levels-setup.json');\n\nfunction LevelsScreen({onSelectLevel, show, setActiveScreen}) {\n    const levelThreshold = (parseInt(localStorage.getItem('last-completed-level')) || 0) + 1\n\n    return (\n        <div className={`screen levelsScreen ${show && 'show'}`}>\n            <h1>Choose Level</h1>\n\n            {show && <>\n                <div className=\"levelsBtnsWrapper\">\n                    {levels.map((level, index) => (\n                        <button\n                            onClick={() => index <= levelThreshold && onSelectLevel(index)}\n                            className={`levelNumberBtn linkBtn ${index >= 100 ? 'threeDigits' : ''}  ${index > levelThreshold ? 'disabledLevel' : ''}`}\n                            key={index}\n                        >{index + 1}</button>\n                    ))}\n                </div>\n\n                <button\n                    title=\"Go back\"\n                    className=\"backBtn btn linkBtn\"\n                    onClick={() => setActiveScreen(SCREENS.game)}\n                >\n                    Go Back\n                </button>\n            </>}\n        </div>\n    );\n}\n\nexport default LevelsScreen;\n","import React from \"react\";\nimport {SCREENS} from \"./App\";\n\n\nconst requestFunction = document.body.requestFullscreen || document.body.webkitRequestFullscreen  || (() => {})\nconst exitFunction = document.exitFullscreen || document.webkitExitFullscreen || (() => {})\nconst toggleFullscreen = () => {\n    const fullScreenState = document.fullscreenElement || document.webkitIsFullScreen || false\n\n    if (fullScreenState) {\n        exitFunction.call(document)\n    } else {\n        requestFunction.call(document.body)\n    }\n\n    if (window.navigator.vibrate) {\n        window.navigator.vibrate(200);\n    }\n}\n\n\nexport const Header = ({setActiveScreen, restartHandler, undoHandler}) => {\n\n    return <div className=\"header\">\n        <button\n            onClick={() => setActiveScreen(SCREENS.settings)}\n            className=\"settingsBtn btn linkBtn\"\n            title=\"Settings\"\n        >\n            <svg>\n                <use xlinkHref=\"#icon-settings\"/>\n            </svg>\n        </button>\n\n        <button\n            onClick={() => setActiveScreen(SCREENS.levels)}\n            className=\"levelsBtn btn linkBtn\"\n            title=\"Choose Level\"\n        >\n            <svg>\n                <use xlinkHref=\"#icon-levels\"/>\n            </svg>\n        </button>\n\n        <button\n            onClick={toggleFullscreen}\n            className=\"fullscreenBtn btn linkBtn\"\n            title=\"Switch To Full Screen\"\n        >\n            <svg>\n                <use xlinkHref=\"#icon-fullscreen\" />\n            </svg>\n        </button>\n\n        <button\n            onClick={restartHandler}\n            className=\"restartBtn btn linkBtn\"\n            title=\"Restart Level\"\n        >\n            <svg>\n                <use xlinkHref=\"#icon-reload\"/>\n            </svg>\n        </button>\n\n        <button\n            onClick={undoHandler}\n            className=\"undoBtn btn linkBtn\"\n            title=\"Undo\"\n        >\n            <svg>\n                <use xlinkHref=\"#icon-undo\"/>\n            </svg>\n        </button>\n    </div>\n}","import React from \"react\";\nimport {SCREENS} from \"./App\";\n\nfunction SettingsScreen({setActiveScreen, show}) {\n    return (\n        <div className={`screen settingsScreen ${show && 'show'}`} >\n            <h1>Settings</h1>\n\n            <button\n                title=\"Go back\"\n                className=\"backBtn btn linkBtn\"\n                onClick={() => setActiveScreen(SCREENS.game)}\n            >\n                Go Back\n            </button>\n        </div>\n    );\n}\n\nexport default SettingsScreen;\n","export const sendAnalyticsEvent = (eventName: string, args: any) => {\n    // @ts-ignore\n    window.gtag('event', eventName, args);\n}","import './css/App.css';\nimport Tube from \"./Tube\";\nimport React, {useEffect, useState} from \"react\";\nimport {checkLevelCompletion} from \"./levels.js\";\nimport {throttle} from \"throttle-debounce\";\nimport NextScreen from \"./NextScreen\";\nimport LevelsScreen from \"./LevelsScreen\";\nimport deepcopy from \"deepcopy\";\nimport {Header} from \"./Header\";\nimport SettingsScreen from \"./SettingsScreen\";\nimport {sendAnalyticsEvent} from \"./analytics\";\n\nexport const SCREENS = {\n    game: 'game',\n    nextLevel: 'nextLevel',\n    settings: 'settings',\n    levels: 'levels',\n}\n\nconst partseLevel = (levelString) => {\n    const level = []\n    for (let i = 0; i < levelString.length / 4; i++) {\n        level[i] = [\n            parseInt(levelString[i * 4], 32),\n            parseInt(levelString[i * 4 + 1], 32),\n            parseInt(levelString[i * 4 + 2], 32),\n            parseInt(levelString[i * 4 + 3], 32)\n        ]\n    }\n\n    level.push([], [])\n\n    return level\n}\nconst levels = require('./levels-setup.json').map(partseLevel);\n\nfunction App() {\n    const [tubes, setTubes] = useState(JSON.parse(JSON.stringify(levels[0])))\n    const [selected, setSelected] = useState(-1)\n    const [arrowPosition, setArrowPosition] = useState(-1)\n    const [isLevelComplete, setLevelComplete] = useState(false)\n    const [currentLevelIndex, setCurrentLevelIndex] = useState(0)\n    const [activeScreen, setActiveScreenOriginal] = useState('gameScreen')\n    const [actionHistory, setActionHistory] = useState([])\n    const [levelSetupTimestamp, setLevelSetupTimestamp] = useState(Date.now())\n\n    const setActiveScreen = (value) => {\n        setActiveScreenOriginal(value)\n        sendAnalyticsEvent('activate_screen-value', {level: currentLevelIndex})\n    }\n\n    const setupLevel = (index = currentLevelIndex) => {\n        if (levels[index]) {\n            setTubes(deepcopy(levels[index]))\n            setActionHistory([])\n            setLevelComplete(false)\n            setActiveScreen(SCREENS.game)\n\n\n            setSelected(-1)\n            setCurrentLevelIndex(index)\n            localStorage.setItem('level', index.toString())\n\n            setLevelSetupTimestamp(Date.now())\n            sendAnalyticsEvent('setup_level', {level: index})\n        }\n    }\n\n    const localLevel = parseInt(localStorage.getItem('level'))\n    if (!isNaN(localLevel) && localLevel !== currentLevelIndex) {\n        setupLevel(localLevel)\n    }\n\n    const manipulateTubes = (index) => {\n        if (selected === -1) {\n            setSelected(index)\n        } else {\n            if (index !== selected) {\n                const from = tubes[selected]\n                const to = tubes[index]\n\n                let layersCount = 0\n                while (\n                    from.length !== 0 && to.length !== 4\n                    && (from[from.length - 1] === to[to.length - 1] || to.length === 0)\n                    ) {\n                    to.push(from.pop())\n                    layersCount++\n                }\n\n                setActionHistory([...actionHistory, {from: selected, to: index, layers: layersCount}])\n                setTubes(tubes)\n\n                setSelected(layersCount ? -1 : index)\n            } else {\n                setSelected(selected === index ? -1 : index)\n            }\n        }\n\n        if (checkLevelCompletion(tubes)) {\n            setTimeout(() => {\n                setLevelComplete(true)\n\n                const prevLastCompletedLevel = parseInt(localStorage.getItem('last-completed-level'))\n                localStorage.setItem('last-completed-level', Math.max(currentLevelIndex, prevLastCompletedLevel).toString())\n                setActiveScreen(SCREENS.nextLevel)\n\n                sendAnalyticsEvent('level_completed', {\n                    level: currentLevelIndex,\n                    solution: actionHistory,\n                    time: (Date.now() - levelSetupTimestamp) / 1000\n                })\n            }, 500)\n        }\n    }\n\n    const keyupHandler = (e) => {\n        if (!e) return\n\n        let pos\n        if (e.key === 'ArrowRight') {\n            pos = arrowPosition + 1\n            sendAnalyticsEvent('tube_key-right', {level: currentLevelIndex})\n        } else if (e.key === 'ArrowLeft') {\n            pos = arrowPosition - 1\n            sendAnalyticsEvent('tube_key-left', {level: currentLevelIndex})\n        } else if (e.key === 'Enter') {\n            if (activeScreen === 'nextScreen') {\n                setupLevel(currentLevelIndex + 1)\n                return\n            }\n\n            if (selected === -1) {\n                setSelected(arrowPosition)\n            } else if (arrowPosition === selected) {\n                setSelected(-1)\n            } else {\n                manipulateTubes(arrowPosition)\n                sendAnalyticsEvent('tube_keydown', {level: currentLevelIndex})\n            }\n\n            return\n        }\n\n        if (pos > tubes.length - 1) {\n            pos = 0\n        } else if (pos < 0) {\n            pos = tubes.length - 1\n        }\n\n        setArrowPosition(!isNaN(pos) ? pos : -1)\n    }\n\n    // rewrite every render to have binding to setState, call it to prevent new function after reload reload\n    window.onkeydown = throttle(100, false, keyupHandler)\n    window.onkeydown()\n\n    const clickTubeHandler = (index) => {\n        setArrowPosition(-1)\n        sendAnalyticsEvent('tube_clicked', {level: currentLevelIndex})\n        manipulateTubes(index)\n    }\n\n    const undo = () => {\n        const lastAction = actionHistory.pop()\n        if (lastAction) {\n            const updTubes = deepcopy(tubes)\n            for (let i = 0; i < lastAction.layers; i++) {\n                updTubes[lastAction.from].push(updTubes[lastAction.to].pop())\n            }\n\n            setTubes(updTubes)\n            setActionHistory(actionHistory)\n            sendAnalyticsEvent('tube_left', {level: currentLevelIndex})\n        }\n    }\n\n    const restartLevel = () => {\n        sendAnalyticsEvent('level_restarted', {\n            level: currentLevelIndex,\n            history: actionHistory,\n            time: (Date.now() - levelSetupTimestamp) / 1000\n        })\n\n        setupLevel()\n    }\n\n    return (\n        <div className=\"App\">\n            <Header\n                undoHandler={undo}\n                restartHandler={restartLevel}\n                setActiveScreen={setActiveScreen}\n            />\n\n            <h1 className=\"levelTitle\">Level: {currentLevelIndex + 1} {isLevelComplete && ' - completed!'}</h1>\n\n            <div className=\"level\">\n                {tubes.map((layers, index) => (\n                    <Tube\n                        layers={layers}\n                        selected={index === selected}\n                        hovered={index === arrowPosition}\n                        onClick={() => clickTubeHandler(index)}\n                        key={index}\n                    />\n                ))}\n            </div>\n\n            <NextScreen\n                show={activeScreen === SCREENS.nextLevel}\n                switchToNextLevel={() => setupLevel(currentLevelIndex + 1)}\n            />\n\n            <LevelsScreen\n                show={activeScreen === SCREENS.levels}\n                onSelectLevel={setupLevel}\n                setActiveScreen={setActiveScreen}\n            />\n\n            <SettingsScreen\n                show={activeScreen === SCREENS.settings}\n                setActiveScreen={setActiveScreen}\n            />\n        </div>\n    );\n}\n\nexport default App;","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}